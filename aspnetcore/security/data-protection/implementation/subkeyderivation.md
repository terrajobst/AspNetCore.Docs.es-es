---
title: "Derivación de subclave y cifrado autenticado"
author: rick-anderson
description: 
keywords: "Núcleo de ASP.NET,"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 34bb58a3-5a9a-41e5-b090-08f75b4bbefa
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 24ce71b417599bea22b7fae8b384db599f9e907c
ms.sourcegitcommit: 0b6c8e6d81d2b3c161cd375036eecbace46a9707
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/11/2017
---
# <a name="subkey-derivation-and-authenticated-encryption"></a><span data-ttu-id="9c02d-103">Derivación de subclave y cifrado autenticado</span><span class="sxs-lookup"><span data-stu-id="9c02d-103">Subkey Derivation and Authenticated Encryption</span></span>

<a name=data-protection-implementation-subkey-derivation></a>

<span data-ttu-id="9c02d-104">La mayoría de las teclas en el anillo de clave contiene alguna forma de entropía y tendrá algorítmica información que indica "cifrado de modo CBC + validación HMAC" o "cifrado de GCM + validación".</span><span class="sxs-lookup"><span data-stu-id="9c02d-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="9c02d-105">En estos casos, nos referimos a la entropía incrustada como el material de creación de claves maestras (o KM) para esta clave y llevamos a cabo una función de derivación de claves para derivar las claves que se usará para las operaciones criptográficas reales.</span><span class="sxs-lookup"><span data-stu-id="9c02d-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="9c02d-106">Las claves son abstractas, y una implementación personalizada posible que no funcionen como sigue.</span><span class="sxs-lookup"><span data-stu-id="9c02d-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="9c02d-107">Si la clave proporciona su propia implementación de IAuthenticatedEncryptor en lugar de utilizar una de nuestras fábricas integradas, el mecanismo que se describe en esta sección ya no se aplica.</span><span class="sxs-lookup"><span data-stu-id="9c02d-107">If the key provides its own implementation of IAuthenticatedEncryptor rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name=data-protection-implementation-subkey-derivation-aad></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="9c02d-108">Datos autenticados adicionales y subclave derivación</span><span class="sxs-lookup"><span data-stu-id="9c02d-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="9c02d-109">La interfaz IAuthenticatedEncryptor actúa como la interfaz básica para todas las operaciones de cifrado autenticado.</span><span class="sxs-lookup"><span data-stu-id="9c02d-109">The IAuthenticatedEncryptor interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="9c02d-110">Su método Encrypt toma dos búferes: texto sin formato y additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="9c02d-110">Its Encrypt method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="9c02d-111">El flujo de contenido de texto simple sin modificar la llamada a IDataProtector.Protect, pero el AAD generada por el sistema y consta de tres componentes:</span><span class="sxs-lookup"><span data-stu-id="9c02d-111">The plaintext contents flow unchanged the call to IDataProtector.Protect, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="9c02d-112">El encabezado de mágico de 32 bits 09 F0 C9 F0 que identifica esta versión del sistema de protección de datos.</span><span class="sxs-lookup"><span data-stu-id="9c02d-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="9c02d-113">El identificador de clave de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="9c02d-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="9c02d-114">Una cadena de longitud variable formado a partir de la cadena de fin que creó el IDataProtector que está realizando esta operación.</span><span class="sxs-lookup"><span data-stu-id="9c02d-114">A variable-length string formed from the purpose chain that created the IDataProtector that is performing this operation.</span></span>

<span data-ttu-id="9c02d-115">Dado que el AAD es única para la tupla de los tres componentes, podemos usar se pueden para derivar nuevas claves KM en lugar de usar KM propio en todos nuestros operaciones de cifrado.</span><span class="sxs-lookup"><span data-stu-id="9c02d-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="9c02d-116">Para todas las llamadas a IAuthenticatedEncryptor.Encrypt, el siguiente proceso de derivación de claves tiene lugar:</span><span class="sxs-lookup"><span data-stu-id="9c02d-116">For every call to IAuthenticatedEncryptor.Encrypt, the following key derivation process takes place:</span></span>

<span data-ttu-id="9c02d-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (contextHeader K_M, AAD, || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="9c02d-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="9c02d-118">En este caso, estamos llamando a KDF SP800-108 NIST en modo de contador (vea [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), seg.</span><span class="sxs-lookup"><span data-stu-id="9c02d-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec.</span></span> <span data-ttu-id="9c02d-119">5.1) con los siguientes parámetros:</span><span class="sxs-lookup"><span data-stu-id="9c02d-119">5.1) with the following parameters:</span></span>

* <span data-ttu-id="9c02d-120">Clave de derivación de claves (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="9c02d-120">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="9c02d-121">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="9c02d-121">PRF = HMACSHA512</span></span>

* <span data-ttu-id="9c02d-122">etiqueta = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="9c02d-122">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="9c02d-123">contexto = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="9c02d-123">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="9c02d-124">El encabezado de contexto es de longitud variable y actúa esencialmente como una huella digital de los algoritmos para el que nos estamos derivación K_E y K_H.</span><span class="sxs-lookup"><span data-stu-id="9c02d-124">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="9c02d-125">El modificador de clave es una cadena de 128 bits que se genera de forma aleatoria para cada llamada a cifrar y que sirve para asegurarse de con una sobrecarga de probabilidad que KE y KH son únicos para esta operación de cifrado de autenticación específico, aunque todas las demás entradas a KDF son constante.</span><span class="sxs-lookup"><span data-stu-id="9c02d-125">The key modifier is a 128-bit string randomly generated for each call to Encrypt and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="9c02d-126">Para el cifrado del modo CBC + las operaciones de validación de HMAC, | K_E | es la longitud de la clave de cifrado de bloques simétrico y | K_H | es el tamaño de resumen de la rutina HMAC.</span><span class="sxs-lookup"><span data-stu-id="9c02d-126">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="9c02d-127">Para el cifrado de GCM + las operaciones de validación, | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="9c02d-127">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="9c02d-128">Cifrado del modo CBC + validación HMAC</span><span class="sxs-lookup"><span data-stu-id="9c02d-128">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="9c02d-129">Una vez K_E se genera mediante el mecanismo anterior, se genera un vector de inicialización aleatorio y ejecutar el algoritmo de cifrado de bloques simétrico para cifrar el texto sin formato.</span><span class="sxs-lookup"><span data-stu-id="9c02d-129">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="9c02d-130">El vector de inicialización y el texto cifrado, a continuación, se ejecutan a través de la rutina HMAC que se inicializa con la clave K_H para generar el equipo Mac.</span><span class="sxs-lookup"><span data-stu-id="9c02d-130">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="9c02d-131">Este proceso y el valor devuelto se representa gráficamente a continuación.</span><span class="sxs-lookup"><span data-stu-id="9c02d-131">This process and the return value is represented graphically below.</span></span>

![Valor devuelto y el proceso de modo CBC](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="9c02d-133">*salida: = keyModifier || IV || E_cbc (datos K_E, iv) || HMAC (K_H, iv || E_cbc (datos K_E, iv))*</span><span class="sxs-lookup"><span data-stu-id="9c02d-133">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="9c02d-134">La implementación de IDataProtector.Protect le [anteponer el encabezado mágica y el Id. de clave](authenticated-encryption-details.md#data-protection-implementation-authenticated-encryption-details) a salida antes de devolverlo al llamador.</span><span class="sxs-lookup"><span data-stu-id="9c02d-134">The IDataProtector.Protect implementation will [prepend the magic header and key id](authenticated-encryption-details.md#data-protection-implementation-authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="9c02d-135">Dado que el encabezado mágica y el Id. de clave son implícitamente forma parte de [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), y dado que el modificador de tecla se introduce como entrada a KDF, esto significa que cada byte único de la última carga devuelta es autenticado por el equipo Mac.</span><span class="sxs-lookup"><span data-stu-id="9c02d-135">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="9c02d-136">El cifrado del modo de Galois/contador + validación</span><span class="sxs-lookup"><span data-stu-id="9c02d-136">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="9c02d-137">Una vez K_E se genera mediante el mecanismo anterior, se genera un valor aleatorio de 96 bits nonce y ejecutar el algoritmo de cifrado de bloques simétrico para cifrar el texto sin formato y generar la etiqueta de autenticación de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="9c02d-137">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Valor devuelto y proceso en modo de GCM](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="9c02d-139">*salida: = keyModifier || nonce || E_gcm (K_E, nonce, de datos) || authTag*</span><span class="sxs-lookup"><span data-stu-id="9c02d-139">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="9c02d-140">Aunque GCM forma nativa es compatible con el concepto de AAD, nos estamos todavía alimentación AAD solo KDF original, para pasar una cadena vacía a GCM para su parámetro AAD.</span><span class="sxs-lookup"><span data-stu-id="9c02d-140">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="9c02d-141">La razón para esto es dos vertientes.</span><span class="sxs-lookup"><span data-stu-id="9c02d-141">The reason for this is two-fold.</span></span> <span data-ttu-id="9c02d-142">En primer lugar, [para admitir la agilidad](context-headers.md#data-protection-implementation-context-headers) nunca queremos usar K_M directamente como la clave de cifrado.</span><span class="sxs-lookup"><span data-stu-id="9c02d-142">First, [to support agility](context-headers.md#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="9c02d-143">Además, GCM impone requisitos de unicidad muy estrictos en sus entradas.</span><span class="sxs-lookup"><span data-stu-id="9c02d-143">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="9c02d-144">La probabilidad de que la rutina de cifrado de GCM alguna vez invocado con dos o más distintos conjuntos de datos de entrada con el mismo (clave, nonce) par no debe superar los 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="9c02d-144">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="9c02d-145">Si se soluciona K_E no podemos realizar más de 2 ^ 32 operaciones de cifrado antes de que se ejecute mantiene del 2 ^ limitar -32.</span><span class="sxs-lookup"><span data-stu-id="9c02d-145">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="9c02d-146">Esto puede parecer un gran número de operaciones, pero un servidor web de tráfico elevado puede ir a través de solicitudes de 4 mil millones en días simples, bien dentro de la duración normal de estas claves.</span><span class="sxs-lookup"><span data-stu-id="9c02d-146">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="9c02d-147">A estar al día de 2 ^ límite de probabilidad-32, seguimos utilizar un modificador de clave de 128 bits y 96 bits nonce, que extiende radicalmente el número de operaciones puede usar para cualquier K_M determinado.</span><span class="sxs-lookup"><span data-stu-id="9c02d-147">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="9c02d-148">Para simplificar el trabajo de diseño compartimos la ruta de acceso del código KDF entre las operaciones de cifrado CBC y GCM y, puesto que ya se considera AAD en KDF no es necesario que se reenvíe a la rutina GCM.</span><span class="sxs-lookup"><span data-stu-id="9c02d-148">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there is no need to forward it to the GCM routine.</span></span>
